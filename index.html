<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futures Leverage Trading Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {},
            }
        }
    </script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans transition-colors duration-200">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        function App() {
            const [theme, setTheme] = useState(localStorage.getItem('theme') || 'light');
            const [accountSize, setAccountSize] = useState(localStorage.getItem('accountSize') || '');
            const [trades, setTrades] = useState(() => {
                const savedTrades = localStorage.getItem('trades');
                return savedTrades ? JSON.parse(savedTrades) : [];
            });
            const [showAddForm, setShowAddForm] = useState(false);
            const [editingTradeIndex, setEditingTradeIndex] = useState(null);
            const [livePrices, setLivePrices] = useState({});
            const [lastPriceUpdate, setLastPriceUpdate] = useState(null);
            const [priceTargets, setPriceTargets] = useState(() => {
                const savedTargets = localStorage.getItem('priceTargets');
                return savedTargets ? JSON.parse(savedTargets) : {};
            });
            const [portfolioTargets, setPortfolioTargets] = useState(() => {
                const savedPortfolioTargets = localStorage.getItem('portfolioTargets');
                return savedPortfolioTargets ? JSON.parse(savedPortfolioTargets) : [1, 2, 3]; // Default to 1%, 2%, 3%
            });
            const [openTradesExpanded, setOpenTradesExpanded] = useState(() => {
                const savedState = localStorage.getItem('openTradesExpanded');
                return savedState !== null ? JSON.parse(savedState) : true; // Default to expanded
            });
            const [portfolioTargetsExpanded, setPortfolioTargetsExpanded] = useState(() => {
                const savedState = localStorage.getItem('portfolioTargetsExpanded');
                return savedState !== null ? JSON.parse(savedState) : {}; // Default to empty object (all expanded)
            });
            const [priceTargetsExpanded, setPriceTargetsExpanded] = useState(() => {
                const savedState = localStorage.getItem('priceTargetsExpanded');
                return savedState !== null ? JSON.parse(savedState) : {}; // Default to empty object (all expanded)
            });
            const cryptos = ['BTC', 'ETH'];

            const calculateIndividualLiquidationPrice = (trade) => {
                const numericAccountSize = parseCurrencyInput(accountSize);
                const availableMargin = numericAccountSize > 0 ? numericAccountSize : trade.marginUsed;

                // Calculate liquidation price where total loss equals available margin
                if (trade.direction === 'long') {
                    // For long position: liqPrice = entryPrice - (availableMargin / positionSize)
                    return trade.entryPrice - (availableMargin / trade.positionSize);
                } else {
                    // For short position: liqPrice = entryPrice + (availableMargin / positionSize)
                    return trade.entryPrice + (availableMargin / trade.positionSize);
                }
            };

            useEffect(() => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                localStorage.setItem('theme', theme);
            }, [theme]);

            useEffect(() => {
                localStorage.setItem('accountSize', accountSize);
                // Recalculate liquidation prices when account size changes
                if (trades.length > 0) {
                    const updatedTrades = trades.map(trade => ({
                        ...trade,
                        liqPrice: calculateIndividualLiquidationPrice(trade)
                    }));
                    setTrades(updatedTrades);
                }
            }, [accountSize]);

            useEffect(() => {
                localStorage.setItem('trades', JSON.stringify(trades));
                // Recalculate all price targets when trades change
                recalculateAllPriceTargets();
            }, [trades]);

            useEffect(() => {
                localStorage.setItem('priceTargets', JSON.stringify(priceTargets));
            }, [priceTargets]);

            useEffect(() => {
                localStorage.setItem('portfolioTargets', JSON.stringify(portfolioTargets));
            }, [portfolioTargets]);

            useEffect(() => {
                localStorage.setItem('openTradesExpanded', JSON.stringify(openTradesExpanded));
            }, [openTradesExpanded]);

            useEffect(() => {
                localStorage.setItem('portfolioTargetsExpanded', JSON.stringify(portfolioTargetsExpanded));
            }, [portfolioTargetsExpanded]);

            useEffect(() => {
                localStorage.setItem('priceTargetsExpanded', JSON.stringify(priceTargetsExpanded));
            }, [priceTargetsExpanded]);

            // Fetch live prices from CoinGecko API
            const fetchLivePrices = async () => {
                try {
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd');
                    const data = await response.json();

                    const prices = {
                        BTC: data.bitcoin?.usd || 0,
                        ETH: data.ethereum?.usd || 0
                    };

                    setLivePrices(prices);
                    setLastPriceUpdate(new Date());
                } catch (error) {
                    console.error('Error fetching live prices:', error);
                }
            };

            // Fetch prices on component mount and set up interval
            useEffect(() => {
                fetchLivePrices(); // Initial fetch
                const interval = setInterval(fetchLivePrices, 30000); // Update every 30 seconds

                return () => clearInterval(interval);
            }, []);

            const toggleTheme = () => {
                setTheme(theme === 'light' ? 'dark' : 'light');
            };

            const addTrade = (newTrade) => {
                const notionalValue = newTrade.positionSize * newTrade.entryPrice;
                const marginUsed = notionalValue / newTrade.leverage;
                const tempTrade = { ...newTrade, notionalValue, marginUsed };
                const liqPrice = calculateIndividualLiquidationPrice(tempTrade);

                setTrades([...trades, { ...newTrade, notionalValue, marginUsed, liqPrice }]);
                setShowAddForm(false);
            };

            const updateTrade = (index, updatedTrade) => {
                const notionalValue = updatedTrade.positionSize * updatedTrade.entryPrice;
                const marginUsed = notionalValue / updatedTrade.leverage;
                const tempTrade = { ...updatedTrade, notionalValue, marginUsed };
                const liqPrice = calculateIndividualLiquidationPrice(tempTrade);

                const newTrades = [...trades];
                newTrades[index] = { ...updatedTrade, notionalValue, marginUsed, liqPrice };
                setTrades(newTrades);
                setEditingTradeIndex(null);
            };

            const deleteTrade = (index) => {
                const newTrades = trades.filter((_, i) => i !== index);
                setTrades(newTrades);
                if (editingTradeIndex === index) {
                    setEditingTradeIndex(null);
                }
            };

            const formatUSD = (amount) => {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                }).format(amount);
            };

            const formatCurrencyInput = (value) => {
                // Remove all non-numeric characters except decimal point
                const numericValue = value.replace(/[^\d.]/g, '');
                const parts = numericValue.split('.');

                // Format the integer part with commas
                if (parts[0]) {
                    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                }

                // Limit decimal places to 2
                if (parts[1]) {
                    parts[1] = parts[1].substring(0, 2);
                }

                return parts.join('.');
            };

            const parseCurrencyInput = (value) => {
                // Remove commas and parse as float
                return parseFloat(value.replace(/,/g, '')) || 0;
            };

            const calculateBreakevenPrice = (crypto) => {
                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                if (cryptoTrades.length === 0) return null;

                let totalLongSize = 0;
                let totalShortSize = 0;
                let totalLongValue = 0;
                let totalShortValue = 0;

                cryptoTrades.forEach(trade => {
                    if (trade.direction === 'long') {
                        totalLongSize += trade.positionSize;
                        totalLongValue += trade.positionSize * trade.entryPrice;
                    } else {
                        totalShortSize += trade.positionSize;
                        totalShortValue += trade.positionSize * trade.entryPrice;
                    }
                });

                // If only long or only short positions, breakeven is weighted average entry price
                if (totalShortSize === 0 && totalLongSize > 0) {
                    return totalLongValue / totalLongSize;
                }
                if (totalLongSize === 0 && totalShortSize > 0) {
                    return totalShortValue / totalShortSize;
                }

                // If both long and short positions exist, calculate net breakeven
                const netSize = totalLongSize - totalShortSize;
                const netValue = totalLongValue - totalShortValue;

                if (Math.abs(netSize) < 0.0001) {
                    // Positions are perfectly hedged
                    return null;
                }

                return netValue / netSize;
            };

            const calculateLiquidationPrice = (crypto) => {
                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                if (cryptoTrades.length === 0) return null;

                let totalMarginUsed = 0;
                let totalLongSize = 0;
                let totalShortSize = 0;
                let totalLongValue = 0;
                let totalShortValue = 0;

                cryptoTrades.forEach(trade => {
                    totalMarginUsed += trade.marginUsed;
                    if (trade.direction === 'long') {
                        totalLongSize += trade.positionSize;
                        totalLongValue += trade.positionSize * trade.entryPrice;
                    } else {
                        totalShortSize += trade.positionSize;
                        totalShortValue += trade.positionSize * trade.entryPrice;
                    }
                });

                const netSize = totalLongSize - totalShortSize;
                const netValue = totalLongValue - totalShortValue;

                if (Math.abs(netSize) < 0.0001) {
                    // Positions are perfectly hedged - no liquidation price
                    return null;
                }

                // Use account size if available, otherwise use margin used for this crypto
                const accountSizeNum = parseCurrencyInput(accountSize);
                const availableMargin = accountSizeNum > 0 ? accountSizeNum : totalMarginUsed;

                // Calculate liquidation price where total loss equals available margin
                // For net long position: liqPrice = (netValue - availableMargin) / netSize
                // For net short position: liqPrice = (netValue + availableMargin) / netSize
                if (netSize > 0) {
                    // Net long position
                    return (netValue - availableMargin) / netSize;
                } else {
                    // Net short position
                    return (netValue + availableMargin) / netSize;
                }
            };

            const calculateProfit = (crypto, targetPrice) => {
                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                let totalProfit = 0;
                const profits = cryptoTrades.map(trade => {
                    const profit = trade.direction === 'long'
                        ? trade.positionSize * (targetPrice - trade.entryPrice)
                        : trade.positionSize * (trade.entryPrice - targetPrice);
                    totalProfit += profit;
                    return { ...trade, profit };
                });
                return { profits, totalProfit };
            };

            const calculateCurrentProfit = (crypto) => {
                const currentPrice = livePrices[crypto];
                if (!currentPrice) return null;

                return calculateProfit(crypto, currentPrice);
            };

            // Helper function to calculate profit percentages
            const calculateProfitPercentages = (crypto, profitData) => {
                if (!profitData) return null;

                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                if (cryptoTrades.length === 0) return null;

                // Calculate total margin used for this crypto
                const totalCryptoMargin = cryptoTrades.reduce((sum, trade) => sum + trade.marginUsed, 0);

                // Calculate trade profit percentage (profit vs margin used for this crypto)
                const tradeProfitPercentage = totalCryptoMargin > 0 ? (profitData.totalProfit / totalCryptoMargin) * 100 : 0;

                // Calculate account profit percentage (profit vs total account size)
                const numericAccountSize = parseCurrencyInput(accountSize);
                const accountProfitPercentage = numericAccountSize > 0 ? (profitData.totalProfit / numericAccountSize) * 100 : 0;

                return {
                    tradeProfitPercentage,
                    accountProfitPercentage,
                    totalCryptoMargin
                };
            };

            const addPriceTarget = (crypto, targetPrice) => {
                const targetId = Date.now().toString();
                const profitData = calculateProfit(crypto, targetPrice);

                setPriceTargets(prev => ({
                    ...prev,
                    [crypto]: {
                        ...prev[crypto],
                        [targetId]: {
                            id: targetId,
                            targetPrice: targetPrice,
                            profitData: profitData,
                            createdAt: new Date().toISOString()
                        }
                    }
                }));
            };

            const removePriceTarget = (crypto, targetId) => {
                setPriceTargets(prev => {
                    const newTargets = { ...prev };
                    if (newTargets[crypto]) {
                        delete newTargets[crypto][targetId];
                        if (Object.keys(newTargets[crypto]).length === 0) {
                            delete newTargets[crypto];
                        }
                    }
                    return newTargets;
                });
            };

            const recalculateAllPriceTargets = () => {
                setPriceTargets(prev => {
                    const newTargets = { ...prev };
                    Object.keys(newTargets).forEach(crypto => {
                        Object.keys(newTargets[crypto]).forEach(targetId => {
                            const target = newTargets[crypto][targetId];
                            const updatedProfitData = calculateProfit(crypto, target.targetPrice);
                            newTargets[crypto][targetId] = {
                                ...target,
                                profitData: updatedProfitData
                            };
                        });
                    });
                    return newTargets;
                });
            };

            // Calculate the price needed for a crypto to achieve a specific portfolio gain percentage
            const calculatePortfolioTargetPrice = (crypto, portfolioGainPercent) => {
                const numericAccountSize = parseCurrencyInput(accountSize);
                if (numericAccountSize <= 0) return null;

                const targetProfit = (portfolioGainPercent / 100) * numericAccountSize;
                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                if (cryptoTrades.length === 0) return null;

                let totalLongSize = 0;
                let totalShortSize = 0;
                let totalLongValue = 0;
                let totalShortValue = 0;

                cryptoTrades.forEach(trade => {
                    if (trade.direction === 'long') {
                        totalLongSize += trade.positionSize;
                        totalLongValue += trade.positionSize * trade.entryPrice;
                    } else {
                        totalShortSize += trade.positionSize;
                        totalShortValue += trade.positionSize * trade.entryPrice;
                    }
                });

                const netSize = totalLongSize - totalShortSize;
                const netValue = totalLongValue - totalShortValue;

                if (Math.abs(netSize) < 0.0001) {
                    // Positions are perfectly hedged - no price can achieve portfolio gain
                    return null;
                }

                // Calculate required price to achieve target profit
                // For net long: profit = netSize * (targetPrice - avgEntryPrice)
                // For net short: profit = netSize * (avgEntryPrice - targetPrice)
                // Solving for targetPrice: targetPrice = avgEntryPrice + (profit / netSize) for long
                //                         targetPrice = avgEntryPrice - (profit / netSize) for short
                const avgEntryPrice = netValue / netSize;

                if (netSize > 0) {
                    // Net long position
                    return avgEntryPrice + (targetProfit / netSize);
                } else {
                    // Net short position
                    return avgEntryPrice - (targetProfit / netSize);
                }
            };

            // Add a new portfolio target percentage
            const addPortfolioTarget = (percentage) => {
                if (!portfolioTargets.includes(percentage)) {
                    setPortfolioTargets([...portfolioTargets, percentage].sort((a, b) => a - b));
                }
            };

            // Remove a portfolio target percentage
            const removePortfolioTarget = (percentage) => {
                setPortfolioTargets(portfolioTargets.filter(p => p !== percentage));
            };

            // Toggle portfolio targets section expansion for a specific crypto
            const togglePortfolioTargetsExpansion = (crypto) => {
                setPortfolioTargetsExpanded(prev => ({
                    ...prev,
                    [crypto]: !prev[crypto] // Default to true (expanded) if not set
                }));
            };

            // Toggle price targets section expansion for a specific crypto
            const togglePriceTargetsExpansion = (crypto) => {
                setPriceTargetsExpanded(prev => ({
                    ...prev,
                    [crypto]: !prev[crypto] // Default to true (expanded) if not set
                }));
            };

            const totalMargin = trades.reduce((sum, trade) => sum + trade.marginUsed, 0);
            const numericAccountSize = parseCurrencyInput(accountSize);
            const totalMarginRemaining = numericAccountSize > 0 ? Math.max(0, numericAccountSize - totalMargin) : 0;
            const showWarning = numericAccountSize > 0 && totalMargin > numericAccountSize;

            return (
                <div className="container mx-auto p-4 max-w-4xl">
                    <header className="flex justify-between items-center mb-6">
                        <h1 className="text-3xl font-bold">Futures Leverage Trading Calculator</h1>
                        <button 
                            onClick={toggleTheme}
                            className="p-2 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition"
                        >
                            {theme === 'light' ? '🌙' : '☀️'}
                        </button>
                    </header>

                    {/* Account Size */}
                    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
                        <div className="flex items-center space-x-4">
                            <label htmlFor="account-size" className="text-lg font-semibold whitespace-nowrap">Account Size (USD)</label>
                            <input
                                id="account-size"
                                type="text"
                                placeholder="0.00"
                                className="flex-1 p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={accountSize}
                                onChange={(e) => setAccountSize(formatCurrencyInput(e.target.value))}
                            />
                        </div>
                    </div>

                    {/* Open Trades - Collapsible */}
                    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
                        <div className="flex justify-between items-center mb-4">
                            <div className="flex items-center space-x-3">
                                <h2 className="text-xl font-semibold">Open Trades ({trades.length})</h2>
                                <button
                                    onClick={() => setShowAddForm(!showAddForm)}
                                    className="bg-blue-500 text-white px-2 py-1 text-xs rounded hover:bg-blue-600 transition"
                                >
                                    {showAddForm ? 'Cancel' : 'Add Trade'}
                                </button>
                            </div>
                            <button
                                onClick={() => setOpenTradesExpanded(!openTradesExpanded)}
                                className="w-8 h-8 border border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 hover:text-gray-800 dark:hover:text-gray-100 transition rounded flex items-center justify-center text-lg font-medium"
                                title={openTradesExpanded ? 'Minimize section' : 'Maximize section'}
                            >
                                {openTradesExpanded ? '−' : '+'}
                            </button>
                        </div>

                        {/* Add Trade Form - Always visible when shown */}
                        {showAddForm && (
                            <div className="mb-4 p-4 border rounded dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                                <AddTradeForm
                                    addTrade={addTrade}
                                    formatCurrencyInput={formatCurrencyInput}
                                    parseCurrencyInput={parseCurrencyInput}
                                />
                            </div>
                        )}

                        {/* Collapsible content */}
                        {openTradesExpanded && (
                            <>
                                {/* Edit Trade Form - Conditionally shown */}
                                {editingTradeIndex !== null && (
                                    <div className="mb-6 p-4 border rounded dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                                        <EditTradeForm
                                            trade={trades[editingTradeIndex]}
                                            updateTrade={(updatedTrade) => updateTrade(editingTradeIndex, updatedTrade)}
                                            onCancel={() => setEditingTradeIndex(null)}
                                            formatCurrencyInput={formatCurrencyInput}
                                            parseCurrencyInput={parseCurrencyInput}
                                        />
                                    </div>
                                )}

                                {trades.length === 0 ? (
                                    <p className="text-gray-500 dark:text-gray-400 text-center py-8">
                                        No open trades. Click "Add Trade" to get started.
                                    </p>
                                ) : (
                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                        {trades.map((trade, index) => (
                                    <div key={index} className="border p-4 rounded-lg border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm hover:shadow-md dark:hover:shadow-lg transition-shadow">
                                        <div className="flex justify-between items-start mb-3">
                                            <div className="flex items-center space-x-2">
                                                <span className="text-lg font-bold text-gray-800 dark:text-gray-200">
                                                    {trade.crypto}
                                                </span>
                                                <span className={`px-2 py-1 rounded text-xs font-medium ${
                                                    trade.direction === 'long'
                                                        ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                        : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                                }`}>
                                                    {trade.direction.toUpperCase()}
                                                </span>
                                            </div>
                                            <span className="text-sm text-gray-500 dark:text-gray-400">
                                                #{index + 1}
                                            </span>
                                        </div>

                                        <div className="space-y-2 mb-4">
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Size:</span>
                                                <span className="text-sm font-medium">{trade.positionSize.toFixed(4)}</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Entry:</span>
                                                <span className="text-sm font-medium">{formatUSD(trade.entryPrice)}</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Leverage:</span>
                                                <span className="text-sm font-medium">{trade.leverage.toFixed(1)}x</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Margin:</span>
                                                <span className="text-sm font-medium">{formatUSD(trade.marginUsed)}</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Liq Price:</span>
                                                <span className="text-sm font-medium text-red-600 dark:text-red-400">
                                                    {formatUSD(trade.liqPrice)}
                                                </span>
                                            </div>
                                        </div>

                                        <div className="flex space-x-2">
                                            <button
                                                onClick={() => setEditingTradeIndex(index)}
                                                className="flex-1 bg-blue-500 text-white text-sm py-2 px-3 rounded hover:bg-blue-600 transition disabled:opacity-50 disabled:cursor-not-allowed"
                                                disabled={editingTradeIndex !== null}
                                            >
                                                Edit
                                            </button>
                                            <button
                                                onClick={() => deleteTrade(index)}
                                                className="flex-1 bg-red-500 text-white text-sm py-2 px-3 rounded hover:bg-red-600 transition"
                                            >
                                                Delete
                                            </button>
                                        </div>
                                    </div>
                                        ))}
                                    </div>
                                )}
                            </>
                        )}

                        {/* Footer - Always visible when there are trades */}
                        {trades.length > 0 && (
                            <>
                                <div className="mt-4 flex justify-between items-center">
                                    <p className="font-semibold">Total Margin Used: {formatUSD(totalMargin)}</p>
                                    {numericAccountSize > 0 && (
                                        <p className="font-semibold text-green-600 dark:text-green-400">
                                            Total Margin Remaining: {formatUSD(totalMarginRemaining)}
                                        </p>
                                    )}
                                </div>
                                {showWarning && (
                                    <p className="mt-2 text-red-500">
                                        Warning: Total margin ({formatUSD(totalMargin)}) exceeds account size ({formatUSD(numericAccountSize)})!
                                    </p>
                                )}
                            </>
                        )}
                    </div>

                    {/* Portfolio Targets */}
                    {trades.length > 0 && (
                        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
                            <h2 className="text-xl font-semibold mb-4">Portfolio Targets</h2>
                            {cryptos.map(crypto => {
                                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                                if (cryptoTrades.length === 0) return null;
                                const currentProfitData = calculateCurrentProfit(crypto);
                                return (
                                    <PortfolioTargetsSection
                                        key={crypto}
                                        crypto={crypto}
                                        portfolioTargets={portfolioTargets}
                                        addPortfolioTarget={addPortfolioTarget}
                                        removePortfolioTarget={removePortfolioTarget}
                                        calculatePortfolioTargetPrice={(crypto, percentage) => calculatePortfolioTargetPrice(crypto, percentage)}
                                        formatUSD={formatUSD}
                                        formatCurrencyInput={formatCurrencyInput}
                                        parseCurrencyInput={parseCurrencyInput}
                                        accountSize={accountSize}
                                        currentPrice={livePrices[crypto]}
                                        currentProfitData={currentProfitData}
                                        isExpanded={portfolioTargetsExpanded[crypto] !== false} // Default to true (expanded)
                                        toggleExpansion={() => togglePortfolioTargetsExpansion(crypto)}
                                    />
                                );
                            })}
                        </div>
                    )}

                    {/* Price Targets */}
                    {trades.length > 0 && (
                        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
                            <h2 className="text-xl font-semibold mb-4">Price Targets</h2>
                            {cryptos.map(crypto => {
                                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                                if (cryptoTrades.length === 0) return null;
                                const breakevenPrice = calculateBreakevenPrice(crypto);
                                const liquidationPrice = calculateLiquidationPrice(crypto);
                                const currentPrice = livePrices[crypto];
                                const currentProfitData = calculateCurrentProfit(crypto);
                                const cryptoTargets = priceTargets[crypto] || {};
                                return (
                                    <PriceTargetSection
                                        key={crypto}
                                        crypto={crypto}
                                        breakevenPrice={breakevenPrice}
                                        liquidationPrice={liquidationPrice}
                                        currentPrice={currentPrice}
                                        currentProfitData={currentProfitData}
                                        lastPriceUpdate={lastPriceUpdate}
                                        priceTargets={cryptoTargets}
                                        addPriceTarget={(targetPrice) => addPriceTarget(crypto, targetPrice)}
                                        removePriceTarget={(targetId) => removePriceTarget(crypto, targetId)}
                                        calculateProfit={(targetPrice) => calculateProfit(crypto, targetPrice)}
                                        calculateProfitPercentages={(crypto, profitData) => calculateProfitPercentages(crypto, profitData)}
                                        formatUSD={formatUSD}
                                        formatCurrencyInput={formatCurrencyInput}
                                        parseCurrencyInput={parseCurrencyInput}
                                        accountSize={accountSize}
                                        isExpanded={priceTargetsExpanded[crypto] !== false} // Default to true (expanded)
                                        toggleExpansion={() => togglePriceTargetsExpansion(crypto)}
                                    />
                                );
                            })}
                        </div>
                    )}
                </div>
            );
        }

        function AddTradeForm({ addTrade, formatCurrencyInput, parseCurrencyInput }) {
            const [crypto, setCrypto] = useState('BTC');
            const [direction, setDirection] = useState('long');
            const [entryPrice, setEntryPrice] = useState('');
            const [positionSize, setPositionSize] = useState('');
            const [leverage, setLeverage] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                const ep = parseCurrencyInput ? parseCurrencyInput(entryPrice) : parseFloat(entryPrice.replace(/,/g, ''));
                const ps = parseFloat(positionSize);
                const lev = parseFloat(leverage);
                if (isNaN(ep) || isNaN(ps) || isNaN(lev) || lev <= 0 || ep <= 0) {
                    alert('Please enter valid numbers for entry price, position size, and leverage (all must be greater than 0).');
                    return;
                }
                addTrade({ crypto, direction, entryPrice: ep, positionSize: ps, leverage: lev });
                setEntryPrice('');
                setPositionSize('');
                setLeverage('');
            };

            return (
                <div>
                    <h3 className="text-lg font-semibold mb-4">Add New Trade</h3>
                    <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label htmlFor="add-crypto" className="block mb-1">Cryptocurrency</label>
                            <select
                                id="add-crypto"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={crypto}
                                onChange={(e) => setCrypto(e.target.value)}
                            >
                                <option value="BTC">BTC</option>
                                <option value="ETH">ETH</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="add-direction" className="block mb-1">Direction</label>
                            <select
                                id="add-direction"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={direction}
                                onChange={(e) => setDirection(e.target.value)}
                            >
                                <option value="long">Long</option>
                                <option value="short">Short</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="add-entry-price" className="block mb-1">Average Entry Price (USD)</label>
                            <input
                                id="add-entry-price"
                                type="text"
                                placeholder="0.00"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={entryPrice}
                                onChange={(e) => setEntryPrice(formatCurrencyInput ? formatCurrencyInput(e.target.value) : e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="add-position-size" className="block mb-1">Position Size (Crypto Units)</label>
                            <input
                                id="add-position-size"
                                type="number"
                                step="0.0001"
                                min="0"
                                placeholder="Position size"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={positionSize}
                                onChange={(e) => setPositionSize(e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="add-leverage" className="block mb-1">Leverage</label>
                            <input
                                id="add-leverage"
                                type="number"
                                step="0.1"
                                min="1"
                                placeholder="Leverage"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={leverage}
                                onChange={(e) => setLeverage(e.target.value)}
                            />
                        </div>
                        <div className="md:col-span-2">
                            <button
                                type="submit"
                                className="w-full md:w-auto mt-2 bg-green-500 text-white p-2 rounded hover:bg-green-600 transition"
                            >
                                Add Trade
                            </button>
                        </div>
                    </form>
                </div>
            );
        }

        function EditTradeForm({ trade, updateTrade, onCancel, formatCurrencyInput, parseCurrencyInput }) {
            const [crypto, setCrypto] = useState(trade.crypto);
            const [direction, setDirection] = useState(trade.direction);
            const [entryPrice, setEntryPrice] = useState(formatCurrencyInput ? formatCurrencyInput(trade.entryPrice.toString()) : trade.entryPrice.toString());
            const [positionSize, setPositionSize] = useState(trade.positionSize.toString());
            const [leverage, setLeverage] = useState(trade.leverage.toString());

            const handleSubmit = (e) => {
                e.preventDefault();
                const ep = parseCurrencyInput ? parseCurrencyInput(entryPrice) : parseFloat(entryPrice.replace(/,/g, ''));
                const ps = parseFloat(positionSize);
                const lev = parseFloat(leverage);
                if (isNaN(ep) || isNaN(ps) || isNaN(lev) || lev <= 0 || ep <= 0) {
                    alert('Please enter valid numbers for entry price, position size, and leverage (all must be greater than 0).');
                    return;
                }
                updateTrade({ crypto, direction, entryPrice: ep, positionSize: ps, leverage: lev });
            };

            return (
                <div>
                    <h3 className="text-lg font-semibold mb-4">Edit Trade</h3>
                    <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label htmlFor="edit-crypto" className="block mb-1">Cryptocurrency</label>
                            <select
                                id="edit-crypto"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={crypto}
                                onChange={(e) => setCrypto(e.target.value)}
                            >
                                <option value="BTC">BTC</option>
                                <option value="ETH">ETH</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="edit-direction" className="block mb-1">Direction</label>
                            <select
                                id="edit-direction"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={direction}
                                onChange={(e) => setDirection(e.target.value)}
                            >
                                <option value="long">Long</option>
                                <option value="short">Short</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="edit-entry-price" className="block mb-1">Average Entry Price (USD)</label>
                            <input
                                id="edit-entry-price"
                                type="text"
                                placeholder="0.00"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={entryPrice}
                                onChange={(e) => setEntryPrice(formatCurrencyInput ? formatCurrencyInput(e.target.value) : e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="edit-position-size" className="block mb-1">Position Size (Crypto Units)</label>
                            <input
                                id="edit-position-size"
                                type="number"
                                step="0.0001"
                                min="0"
                                placeholder="Position size"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={positionSize}
                                onChange={(e) => setPositionSize(e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="edit-leverage" className="block mb-1">Leverage</label>
                            <input
                                id="edit-leverage"
                                type="number"
                                step="0.1"
                                min="1"
                                placeholder="Leverage"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={leverage}
                                onChange={(e) => setLeverage(e.target.value)}
                            />
                        </div>
                        <div className="md:col-span-2 space-x-2">
                            <button
                                type="submit"
                                className="mt-2 bg-green-500 text-white p-2 rounded hover:bg-green-600 transition"
                            >
                                Save Changes
                            </button>
                            <button
                                type="button"
                                onClick={onCancel}
                                className="mt-2 bg-gray-500 text-white p-2 rounded hover:bg-gray-600 transition"
                            >
                                Cancel
                            </button>
                        </div>
                    </form>
                </div>
            );
        }

        function PriceTargetSection({ crypto, breakevenPrice, liquidationPrice, currentPrice, currentProfitData, lastPriceUpdate, priceTargets, addPriceTarget, removePriceTarget, calculateProfit, calculateProfitPercentages, formatUSD, formatCurrencyInput, parseCurrencyInput, accountSize, isExpanded, toggleExpansion }) {
            const [targetPrice, setTargetPrice] = useState('');

            const handleCalculate = () => {
                const tp = parseCurrencyInput ? parseCurrencyInput(targetPrice) : parseFloat(targetPrice.replace(/,/g, ''));
                if (isNaN(tp) || tp <= 0) {
                    alert('Please enter a valid target price greater than 0.');
                    return;
                }
                addPriceTarget(tp);
                setTargetPrice(''); // Clear the input after adding
            };

            return (
                <div className="mb-6 p-4 border rounded-lg border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                    <div className="flex justify-between items-center mb-3">
                        <h3 className="text-lg font-semibold">{crypto} Price Targets</h3>
                        <button
                            onClick={toggleExpansion}
                            className="w-8 h-8 border border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 hover:text-gray-800 dark:hover:text-gray-100 transition rounded flex items-center justify-center text-lg font-medium"
                            title={isExpanded ? 'Minimize section' : 'Maximize section'}
                        >
                            {isExpanded ? '−' : '+'}
                        </button>
                    </div>

                    {/* Current Price, Breakeven and Liquidation Price Display */}
                    <div className="mb-4 grid grid-cols-1 lg:grid-cols-5 gap-4">
                        {/* Combined Current Price and Profit/Loss - Takes 3 out of 5 columns (60% instead of 66.7%) */}
                        <div className={`lg:col-span-3 p-3 border rounded ${
                            currentProfitData && currentProfitData.totalProfit >= 0
                                ? 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800'
                                : 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800'
                        }`}>
                            <p className={`text-sm font-medium mb-2 ${
                                currentProfitData && currentProfitData.totalProfit >= 0
                                    ? 'text-green-800 dark:text-green-200'
                                    : 'text-red-800 dark:text-red-200'
                            }`}>
                                <span className="font-semibold">Current Price:</span> {currentPrice ? formatUSD(currentPrice) : 'Loading...'}
                            </p>
                            <p className={`text-sm font-medium mb-1 ${
                                currentProfitData && currentProfitData.totalProfit >= 0
                                    ? 'text-green-800 dark:text-green-200'
                                    : 'text-red-800 dark:text-red-200'
                            }`}>
                                <span className="font-semibold">
                                    {currentProfitData && currentProfitData.totalProfit >= 0 ? 'Estimated Profit:' : 'Estimated Loss:'}
                                </span> {currentProfitData ? formatUSD(Math.abs(currentProfitData.totalProfit)) : 'Calculating...'}
                            </p>
                            {(() => {
                                const percentages = calculateProfitPercentages(crypto, currentProfitData);
                                return percentages && currentProfitData ? (
                                    <div className="flex flex-wrap gap-2 mt-2">
                                        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                                            currentProfitData.totalProfit >= 0
                                                ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                        }`}>
                                            Trade P/L: {percentages.tradeProfitPercentage >= 0 ? '+' : ''}{percentages.tradeProfitPercentage.toFixed(2)}%
                                        </span>
                                        {parseCurrencyInput(accountSize) > 0 && (
                                            <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                                                currentProfitData.totalProfit >= 0
                                                    ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                    : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                            }`}>
                                                Account P/L: {percentages.accountProfitPercentage >= 0 ? '+' : ''}{percentages.accountProfitPercentage.toFixed(2)}%
                                            </span>
                                        )}
                                    </div>
                                ) : null;
                            })()}
                            <p className={`text-xs mt-2 ${
                                currentProfitData && currentProfitData.totalProfit >= 0
                                    ? 'text-green-600 dark:text-green-300'
                                    : 'text-red-600 dark:text-red-300'
                            }`}>
                                {lastPriceUpdate ? `Updated: ${lastPriceUpdate.toLocaleTimeString()}` : 'Fetching live price...'}
                            </p>
                        </div>

                        {/* Breakeven and Liquidation Prices - Stacked vertically in right column, spans 2 columns */}
                        <div className="lg:col-span-2 space-y-4">
                            {/* Breakeven Price */}
                            {breakevenPrice !== null ? (
                                <div className="p-3 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded">
                                    <p className="text-sm font-medium text-blue-800 dark:text-blue-200">
                                        <span className="font-semibold">Breakeven Price:</span> {formatUSD(breakevenPrice)}
                                    </p>
                                    <p className="text-xs text-blue-600 dark:text-blue-300 mt-1">
                                        Price where all {crypto} positions break even
                                    </p>
                                </div>
                            ) : (
                                <div className="p-3 bg-gray-100 dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded">
                                    <p className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                        <span className="font-semibold">Breakeven Price:</span> N/A
                                    </p>
                                    <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                        Positions are perfectly hedged
                                    </p>
                                </div>
                            )}

                            {/* Liquidation Price */}
                            {liquidationPrice !== null ? (
                                <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded">
                                    <p className="text-sm font-medium text-red-800 dark:text-red-200">
                                        <span className="font-semibold">Liquidation Price:</span> {formatUSD(liquidationPrice)}
                                    </p>
                                    <p className="text-xs text-red-600 dark:text-red-300 mt-1">
                                        Price where entire {crypto} position gets liquidated
                                    </p>
                                </div>
                            ) : (
                                <div className="p-3 bg-gray-100 dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded">
                                    <p className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                        <span className="font-semibold">Liquidation Price:</span> N/A
                                    </p>
                                    <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                        Positions are perfectly hedged
                                    </p>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Add Target input - only show when expanded */}
                    {isExpanded && (
                        <div className="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-2 mb-3">
                            <input
                                type="text"
                                placeholder="0.00"
                                className="flex-grow p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={targetPrice}
                                onChange={(e) => setTargetPrice(formatCurrencyInput ? formatCurrencyInput(e.target.value) : e.target.value)}
                            />
                            <button
                                onClick={handleCalculate}
                                className="bg-green-500 text-white p-2 rounded hover:bg-green-600 transition"
                            >
                                Add Target
                            </button>
                        </div>
                    )}

                    {/* Display all price targets */}
                    {Object.keys(priceTargets).length > 0 && (
                        <>
                            {/* Expanded view - full details */}
                            {isExpanded && (
                                <div className="space-y-3">
                                    {Object.values(priceTargets).map((target) => (
                                        <div key={target.id} className="relative p-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded">
                                            {/* Close button */}
                                            <button
                                                onClick={() => removePriceTarget(target.id)}
                                                className="absolute top-2 right-2 w-6 h-6 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 transition flex items-center justify-center text-lg font-normal"
                                                title="Remove target"
                                            >
                                                ×
                                            </button>

                                            <p className="font-semibold mb-2 pr-8">Profits at {formatUSD(target.targetPrice)}:</p>
                                            <div className="space-y-1 text-sm">
                                                {target.profitData.profits.map((item, index) => (
                                                    <p key={index} className="flex justify-between">
                                                        <span>
                                                            {item.direction.charAt(0).toUpperCase() + item.direction.slice(1)} trade (Entry {formatUSD(item.entryPrice)}):
                                                        </span>
                                                        <span className={`font-medium ${item.profit >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                                                            {formatUSD(item.profit)}
                                                        </span>
                                                    </p>
                                                ))}
                                            </div>
                                            <div className="mt-3 pt-2 border-t border-gray-200 dark:border-gray-600">
                                                <p className="flex justify-between font-semibold">
                                                    <span>Total Profit for {crypto}:</span>
                                                    <span className={`${target.profitData.totalProfit >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                                                        {formatUSD(target.profitData.totalProfit)}
                                                    </span>
                                                </p>
                                                {(() => {
                                                    const percentages = calculateProfitPercentages(crypto, target.profitData);
                                                    return percentages ? (
                                                        <div className="flex flex-wrap gap-2 mt-2">
                                                            <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                                                                target.profitData.totalProfit >= 0
                                                                    ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                                    : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                                            }`}>
                                                                Trade P/L: {percentages.tradeProfitPercentage >= 0 ? '+' : ''}{percentages.tradeProfitPercentage.toFixed(2)}%
                                                            </span>
                                                            {parseCurrencyInput(accountSize) > 0 && (
                                                                <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                                                                    target.profitData.totalProfit >= 0
                                                                        ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                                        : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                                                }`}>
                                                                    Account P/L: {percentages.accountProfitPercentage >= 0 ? '+' : ''}{percentages.accountProfitPercentage.toFixed(2)}%
                                                                </span>
                                                            )}
                                                        </div>
                                                    ) : null;
                                                })()}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {/* Minimized view - compact display */}
                            {!isExpanded && (
                                <div className="space-y-2">
                                    {Object.values(priceTargets).map((target) => {
                                        const percentages = calculateProfitPercentages(crypto, target.profitData);
                                        return (
                                            <div key={target.id} className="flex items-center justify-between p-2 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded">
                                                <div className="flex items-center space-x-3">
                                                    <span className="font-medium text-sm">
                                                        {formatUSD(target.targetPrice)} Target
                                                    </span>
                                                    <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                                        target.profitData.totalProfit >= 0
                                                            ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                            : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                                    }`}>
                                                        Total {formatUSD(target.profitData.totalProfit)}
                                                    </span>
                                                    {percentages && (
                                                        <>
                                                            <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                                                target.profitData.totalProfit >= 0
                                                                    ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                                    : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                                            }`}>
                                                                Trade P/L: {percentages.tradeProfitPercentage >= 0 ? '+' : ''}{percentages.tradeProfitPercentage.toFixed(2)}%
                                                            </span>
                                                            {parseCurrencyInput(accountSize) > 0 && (
                                                                <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                                                    target.profitData.totalProfit >= 0
                                                                        ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                                        : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                                                }`}>
                                                                    Account P/L: {percentages.accountProfitPercentage >= 0 ? '+' : ''}{percentages.accountProfitPercentage.toFixed(2)}%
                                                                </span>
                                                            )}
                                                        </>
                                                    )}
                                                </div>
                                                <button
                                                    onClick={() => removePriceTarget(target.id)}
                                                    className="w-6 h-6 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 transition flex items-center justify-center text-lg font-normal"
                                                    title="Remove target"
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }

        function PortfolioTargetsSection({
            crypto,
            portfolioTargets,
            addPortfolioTarget,
            removePortfolioTarget,
            calculatePortfolioTargetPrice,
            formatUSD,
            formatCurrencyInput,
            parseCurrencyInput,
            accountSize,
            currentPrice,
            currentProfitData,
            isExpanded,
            toggleExpansion
        }) {
            const [newTargetPercent, setNewTargetPercent] = useState('');

            const handleAddTarget = () => {
                const percent = parseFloat(newTargetPercent);
                if (isNaN(percent) || percent <= 0) {
                    alert('Please enter a valid percentage greater than 0.');
                    return;
                }
                addPortfolioTarget(percent);
                setNewTargetPercent('');
            };

            const numericAccountSize = parseCurrencyInput(accountSize);
            const showSection = numericAccountSize > 0;

            if (!showSection) {
                return (
                    <div className="mb-6 p-4 border rounded-lg border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                        <div className="flex justify-between items-center">
                            <div className="flex items-center space-x-3">
                                <h3 className="text-lg font-semibold">{crypto} Portfolio Targets</h3>
                                {currentPrice && currentProfitData && (
                                    <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                        currentProfitData.totalProfit >= 0
                                            ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                            : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                    }`}>
                                        Current: {((currentProfitData.totalProfit / parseCurrencyInput(accountSize)) * 100).toFixed(2)}% • {formatUSD(currentPrice)}
                                    </span>
                                )}
                            </div>
                            <button
                                onClick={toggleExpansion}
                                className="w-8 h-8 border border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 hover:text-gray-800 dark:hover:text-gray-100 transition rounded flex items-center justify-center text-lg font-medium"
                                title={isExpanded ? 'Minimize section' : 'Maximize section'}
                            >
                                {isExpanded ? '−' : '+'}
                            </button>
                        </div>
                        <p className="text-gray-600 dark:text-gray-400 text-sm mt-3">
                            Please set an account size to view portfolio targets.
                        </p>
                    </div>
                );
            }

            return (
                <div className="mb-6 p-4 border rounded-lg border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                    <div className="flex justify-between items-center mb-3">
                        <div className="flex items-center space-x-3">
                            <h3 className="text-lg font-semibold">{crypto} Portfolio Targets</h3>
                            {currentPrice && currentProfitData && (
                                <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                    currentProfitData.totalProfit >= 0
                                        ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                        : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                }`}>
                                    Current: {((currentProfitData.totalProfit / parseCurrencyInput(accountSize)) * 100).toFixed(2)}% • {formatUSD(currentPrice)}
                                </span>
                            )}
                        </div>
                        <button
                            onClick={toggleExpansion}
                            className="w-8 h-8 border border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 hover:text-gray-800 dark:hover:text-gray-100 transition rounded flex items-center justify-center text-lg font-medium"
                            title={isExpanded ? 'Minimize section' : 'Maximize section'}
                        >
                            {isExpanded ? '−' : '+'}
                        </button>
                    </div>

                    {/* Compact view when collapsed - horizontal badges */}
                    {!isExpanded && portfolioTargets.length > 0 && (
                        <div className="flex flex-wrap gap-2">
                            {portfolioTargets.map((percentage) => {
                                const targetPrice = calculatePortfolioTargetPrice(crypto, percentage);
                                return (
                                    <div key={percentage} className="inline-flex items-center px-3 py-1.5 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 rounded-full text-sm font-medium">
                                        <span className="font-semibold">{percentage}%</span>
                                        <span className="mx-2">•</span>
                                        <span className="text-xs">
                                            {targetPrice !== null ? formatUSD(targetPrice) : 'N/A'}
                                        </span>
                                    </div>
                                );
                            })}
                        </div>
                    )}

                    {/* Expanded view */}
                    {isExpanded && (
                        <>
                            <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                                Prices needed to achieve specific portfolio gain percentages (Account Size: {formatUSD(numericAccountSize)})
                            </p>

                            {/* Add new target input */}
                            <div className="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-2 mb-4">
                                <input
                                    type="number"
                                    step="0.1"
                                    min="0"
                                    placeholder="Enter percentage (e.g., 5 for 5%)"
                                    className="flex-grow p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                    value={newTargetPercent}
                                    onChange={(e) => setNewTargetPercent(e.target.value)}
                                />
                                <button
                                    onClick={handleAddTarget}
                                    className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 transition"
                                >
                                    Add Target %
                                </button>
                            </div>
                        </>
                    )}

                    {/* Display portfolio targets - only when expanded */}
                    {isExpanded && (
                        <>
                            {portfolioTargets.length > 0 ? (
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                    {portfolioTargets.map((percentage) => {
                                        const targetPrice = calculatePortfolioTargetPrice(crypto, percentage);
                                        const targetProfitAmount = (percentage / 100) * numericAccountSize;

                                        // Always show close button for all targets
                                        const showCloseButton = true;

                                        return (
                                            <div key={percentage} className="relative p-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded">
                                                {/* Close button - fixed logic */}
                                                {showCloseButton && (
                                                    <button
                                                        onClick={() => removePortfolioTarget(percentage)}
                                                        className="absolute top-2 right-2 w-6 h-6 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 transition flex items-center justify-center text-lg font-normal"
                                                        title="Remove target"
                                                    >
                                                        ×
                                                    </button>
                                                )}

                                                <div className={showCloseButton ? "pr-8" : ""}>
                                                    <p className="font-semibold text-sm mb-2">
                                                        {percentage}% Portfolio Gain
                                                    </p>
                                                    <p className="text-xs text-gray-600 dark:text-gray-400 mb-2">
                                                        Target Profit: {formatUSD(targetProfitAmount)}
                                                    </p>
                                                    {targetPrice !== null ? (
                                                        <p className="text-sm">
                                                            <span className="font-medium">Target Price:</span>
                                                            <span className="ml-2 font-semibold text-blue-600 dark:text-blue-400">
                                                                {formatUSD(targetPrice)}
                                                            </span>
                                                        </p>
                                                    ) : (
                                                        <p className="text-sm text-gray-500 dark:text-gray-400">
                                                            N/A (Hedged positions)
                                                        </p>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            ) : (
                                <p className="text-gray-500 dark:text-gray-400 text-center py-4">
                                    No portfolio targets set. Add a percentage target above.
                                </p>
                            )}
                        </>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>