<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futures Leverage Trading Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {},
            }
        }
    </script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans transition-colors duration-200">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        function App() {
            const [theme, setTheme] = useState(localStorage.getItem('theme') || 'light');
            const [accountSize, setAccountSize] = useState(localStorage.getItem('accountSize') || '');
            const [trades, setTrades] = useState(() => {
                const savedTrades = localStorage.getItem('trades');
                return savedTrades ? JSON.parse(savedTrades) : [];
            });
            const [showAddForm, setShowAddForm] = useState(false);
            const [editingTradeIndex, setEditingTradeIndex] = useState(null);
            const [livePrices, setLivePrices] = useState({});
            const [lastPriceUpdate, setLastPriceUpdate] = useState(null);
            const [priceTargets, setPriceTargets] = useState(() => {
                const savedTargets = localStorage.getItem('priceTargets');
                return savedTargets ? JSON.parse(savedTargets) : {};
            });
            const cryptos = ['BTC', 'ETH'];

            useEffect(() => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                localStorage.setItem('theme', theme);
            }, [theme]);

            useEffect(() => {
                localStorage.setItem('accountSize', accountSize);
            }, [accountSize]);

            useEffect(() => {
                localStorage.setItem('trades', JSON.stringify(trades));
                // Recalculate all price targets when trades change
                recalculateAllPriceTargets();
            }, [trades]);

            useEffect(() => {
                localStorage.setItem('priceTargets', JSON.stringify(priceTargets));
            }, [priceTargets]);

            // Fetch live prices from CoinGecko API
            const fetchLivePrices = async () => {
                try {
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd');
                    const data = await response.json();

                    const prices = {
                        BTC: data.bitcoin?.usd || 0,
                        ETH: data.ethereum?.usd || 0
                    };

                    setLivePrices(prices);
                    setLastPriceUpdate(new Date());
                } catch (error) {
                    console.error('Error fetching live prices:', error);
                }
            };

            // Fetch prices on component mount and set up interval
            useEffect(() => {
                fetchLivePrices(); // Initial fetch
                const interval = setInterval(fetchLivePrices, 30000); // Update every 30 seconds

                return () => clearInterval(interval);
            }, []);

            const toggleTheme = () => {
                setTheme(theme === 'light' ? 'dark' : 'light');
            };

            const addTrade = (newTrade) => {
                const notionalValue = newTrade.positionSize * newTrade.entryPrice;
                const marginUsed = notionalValue / newTrade.leverage;
                const liqPrice = newTrade.direction === 'long'
                    ? newTrade.entryPrice * (1 - 1 / newTrade.leverage)
                    : newTrade.entryPrice * (1 + 1 / newTrade.leverage);

                setTrades([...trades, { ...newTrade, notionalValue, marginUsed, liqPrice }]);
                setShowAddForm(false);
            };

            const updateTrade = (index, updatedTrade) => {
                const notionalValue = updatedTrade.positionSize * updatedTrade.entryPrice;
                const marginUsed = notionalValue / updatedTrade.leverage;
                const liqPrice = updatedTrade.direction === 'long'
                    ? updatedTrade.entryPrice * (1 - 1 / updatedTrade.leverage)
                    : updatedTrade.entryPrice * (1 + 1 / updatedTrade.leverage);

                const newTrades = [...trades];
                newTrades[index] = { ...updatedTrade, notionalValue, marginUsed, liqPrice };
                setTrades(newTrades);
                setEditingTradeIndex(null);
            };

            const deleteTrade = (index) => {
                const newTrades = trades.filter((_, i) => i !== index);
                setTrades(newTrades);
                if (editingTradeIndex === index) {
                    setEditingTradeIndex(null);
                }
            };

            const formatUSD = (amount) => {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                }).format(amount);
            };

            const formatCurrencyInput = (value) => {
                // Remove all non-numeric characters except decimal point
                const numericValue = value.replace(/[^\d.]/g, '');
                const parts = numericValue.split('.');

                // Format the integer part with commas
                if (parts[0]) {
                    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                }

                // Limit decimal places to 2
                if (parts[1]) {
                    parts[1] = parts[1].substring(0, 2);
                }

                return parts.join('.');
            };

            const parseCurrencyInput = (value) => {
                // Remove commas and parse as float
                return parseFloat(value.replace(/,/g, '')) || 0;
            };

            const calculateBreakevenPrice = (crypto) => {
                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                if (cryptoTrades.length === 0) return null;

                let totalLongSize = 0;
                let totalShortSize = 0;
                let totalLongValue = 0;
                let totalShortValue = 0;

                cryptoTrades.forEach(trade => {
                    if (trade.direction === 'long') {
                        totalLongSize += trade.positionSize;
                        totalLongValue += trade.positionSize * trade.entryPrice;
                    } else {
                        totalShortSize += trade.positionSize;
                        totalShortValue += trade.positionSize * trade.entryPrice;
                    }
                });

                // If only long or only short positions, breakeven is weighted average entry price
                if (totalShortSize === 0 && totalLongSize > 0) {
                    return totalLongValue / totalLongSize;
                }
                if (totalLongSize === 0 && totalShortSize > 0) {
                    return totalShortValue / totalShortSize;
                }

                // If both long and short positions exist, calculate net breakeven
                const netSize = totalLongSize - totalShortSize;
                const netValue = totalLongValue - totalShortValue;

                if (Math.abs(netSize) < 0.0001) {
                    // Positions are perfectly hedged
                    return null;
                }

                return netValue / netSize;
            };

            const calculateLiquidationPrice = (crypto) => {
                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                if (cryptoTrades.length === 0) return null;

                let totalMarginUsed = 0;
                let totalLongSize = 0;
                let totalShortSize = 0;
                let totalLongValue = 0;
                let totalShortValue = 0;

                cryptoTrades.forEach(trade => {
                    totalMarginUsed += trade.marginUsed;
                    if (trade.direction === 'long') {
                        totalLongSize += trade.positionSize;
                        totalLongValue += trade.positionSize * trade.entryPrice;
                    } else {
                        totalShortSize += trade.positionSize;
                        totalShortValue += trade.positionSize * trade.entryPrice;
                    }
                });

                const netSize = totalLongSize - totalShortSize;
                const netValue = totalLongValue - totalShortValue;

                if (Math.abs(netSize) < 0.0001) {
                    // Positions are perfectly hedged - no liquidation price
                    return null;
                }

                // Use account size if available, otherwise use margin used for this crypto
                const accountSizeNum = parseCurrencyInput(accountSize);
                const availableMargin = accountSizeNum > 0 ? accountSizeNum : totalMarginUsed;

                // Calculate liquidation price where total loss equals available margin
                // For net long position: liqPrice = (netValue - availableMargin) / netSize
                // For net short position: liqPrice = (netValue + availableMargin) / netSize
                if (netSize > 0) {
                    // Net long position
                    return (netValue - availableMargin) / netSize;
                } else {
                    // Net short position
                    return (netValue + availableMargin) / netSize;
                }
            };

            const calculateProfit = (crypto, targetPrice) => {
                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                let totalProfit = 0;
                const profits = cryptoTrades.map(trade => {
                    const profit = trade.direction === 'long'
                        ? trade.positionSize * (targetPrice - trade.entryPrice)
                        : trade.positionSize * (trade.entryPrice - targetPrice);
                    totalProfit += profit;
                    return { ...trade, profit };
                });
                return { profits, totalProfit };
            };

            const calculateCurrentProfit = (crypto) => {
                const currentPrice = livePrices[crypto];
                if (!currentPrice) return null;

                return calculateProfit(crypto, currentPrice);
            };

            const addPriceTarget = (crypto, targetPrice) => {
                const targetId = Date.now().toString();
                const profitData = calculateProfit(crypto, targetPrice);

                setPriceTargets(prev => ({
                    ...prev,
                    [crypto]: {
                        ...prev[crypto],
                        [targetId]: {
                            id: targetId,
                            targetPrice: targetPrice,
                            profitData: profitData,
                            createdAt: new Date().toISOString()
                        }
                    }
                }));
            };

            const removePriceTarget = (crypto, targetId) => {
                setPriceTargets(prev => {
                    const newTargets = { ...prev };
                    if (newTargets[crypto]) {
                        delete newTargets[crypto][targetId];
                        if (Object.keys(newTargets[crypto]).length === 0) {
                            delete newTargets[crypto];
                        }
                    }
                    return newTargets;
                });
            };

            const recalculateAllPriceTargets = () => {
                setPriceTargets(prev => {
                    const newTargets = { ...prev };
                    Object.keys(newTargets).forEach(crypto => {
                        Object.keys(newTargets[crypto]).forEach(targetId => {
                            const target = newTargets[crypto][targetId];
                            const updatedProfitData = calculateProfit(crypto, target.targetPrice);
                            newTargets[crypto][targetId] = {
                                ...target,
                                profitData: updatedProfitData
                            };
                        });
                    });
                    return newTargets;
                });
            };

            const totalMargin = trades.reduce((sum, trade) => sum + trade.marginUsed, 0);
            const numericAccountSize = parseCurrencyInput(accountSize);
            const totalMarginRemaining = numericAccountSize > 0 ? Math.max(0, numericAccountSize - totalMargin) : 0;
            const showWarning = numericAccountSize > 0 && totalMargin > numericAccountSize;

            return (
                <div className="container mx-auto p-4 max-w-4xl">
                    <header className="flex justify-between items-center mb-6">
                        <h1 className="text-3xl font-bold">Futures Leverage Trading Calculator</h1>
                        <button 
                            onClick={toggleTheme}
                            className="p-2 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition"
                        >
                            {theme === 'light' ? '🌙' : '☀️'}
                        </button>
                    </header>

                    {/* Account Size */}
                    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
                        <label htmlFor="account-size" className="block text-lg font-semibold mb-2">Account Size (USD)</label>
                        <input
                            id="account-size"
                            type="text"
                            placeholder="0.00"
                            className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                            value={accountSize}
                            onChange={(e) => setAccountSize(formatCurrencyInput(e.target.value))}
                        />
                    </div>

                    {/* Open Trades - Always visible */}
                    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-semibold">Open Trades</h2>
                            <button
                                onClick={() => setShowAddForm(!showAddForm)}
                                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition"
                            >
                                {showAddForm ? 'Cancel' : 'Add Trade'}
                            </button>
                        </div>

                        {/* Add Trade Form - Conditionally shown */}
                        {showAddForm && (
                            <div className="mb-6 p-4 border rounded dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                                <AddTradeForm
                                    addTrade={addTrade}
                                    formatCurrencyInput={formatCurrencyInput}
                                    parseCurrencyInput={parseCurrencyInput}
                                />
                            </div>
                        )}

                        {/* Edit Trade Form - Conditionally shown */}
                        {editingTradeIndex !== null && (
                            <div className="mb-6 p-4 border rounded dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                                <EditTradeForm
                                    trade={trades[editingTradeIndex]}
                                    updateTrade={(updatedTrade) => updateTrade(editingTradeIndex, updatedTrade)}
                                    onCancel={() => setEditingTradeIndex(null)}
                                    formatCurrencyInput={formatCurrencyInput}
                                    parseCurrencyInput={parseCurrencyInput}
                                />
                            </div>
                        )}

                        {trades.length === 0 ? (
                            <p className="text-gray-500 dark:text-gray-400 text-center py-8">
                                No open trades. Click "Add Trade" to get started.
                            </p>
                        ) : (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                {trades.map((trade, index) => (
                                    <div key={index} className="border p-4 rounded-lg border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm hover:shadow-md dark:hover:shadow-lg transition-shadow">
                                        <div className="flex justify-between items-start mb-3">
                                            <div className="flex items-center space-x-2">
                                                <span className="text-lg font-bold text-gray-800 dark:text-gray-200">
                                                    {trade.crypto}
                                                </span>
                                                <span className={`px-2 py-1 rounded text-xs font-medium ${
                                                    trade.direction === 'long'
                                                        ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                                                        : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                                                }`}>
                                                    {trade.direction.toUpperCase()}
                                                </span>
                                            </div>
                                            <span className="text-sm text-gray-500 dark:text-gray-400">
                                                #{index + 1}
                                            </span>
                                        </div>

                                        <div className="space-y-2 mb-4">
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Size:</span>
                                                <span className="text-sm font-medium">{trade.positionSize.toFixed(4)}</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Entry:</span>
                                                <span className="text-sm font-medium">{formatUSD(trade.entryPrice)}</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Leverage:</span>
                                                <span className="text-sm font-medium">{trade.leverage.toFixed(1)}x</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Margin:</span>
                                                <span className="text-sm font-medium">{formatUSD(trade.marginUsed)}</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-sm text-gray-600 dark:text-gray-400">Liq Price:</span>
                                                <span className="text-sm font-medium text-red-600 dark:text-red-400">
                                                    {formatUSD(trade.liqPrice)}
                                                </span>
                                            </div>
                                        </div>

                                        <div className="flex space-x-2">
                                            <button
                                                onClick={() => setEditingTradeIndex(index)}
                                                className="flex-1 bg-blue-500 text-white text-sm py-2 px-3 rounded hover:bg-blue-600 transition disabled:opacity-50 disabled:cursor-not-allowed"
                                                disabled={editingTradeIndex !== null}
                                            >
                                                Edit
                                            </button>
                                            <button
                                                onClick={() => deleteTrade(index)}
                                                className="flex-1 bg-red-500 text-white text-sm py-2 px-3 rounded hover:bg-red-600 transition"
                                            >
                                                Delete
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}

                        {trades.length > 0 && (
                            <>
                                <div className="mt-4 flex justify-between items-center">
                                    <p className="font-semibold">Total Margin Used: {formatUSD(totalMargin)}</p>
                                    {numericAccountSize > 0 && (
                                        <p className="font-semibold text-green-600 dark:text-green-400">
                                            Total Margin Remaining: {formatUSD(totalMarginRemaining)}
                                        </p>
                                    )}
                                </div>
                                {showWarning && (
                                    <p className="mt-2 text-red-500">
                                        Warning: Total margin ({formatUSD(totalMargin)}) exceeds account size ({formatUSD(numericAccountSize)})!
                                    </p>
                                )}
                            </>
                        )}
                    </div>

                    {/* Price Targets */}
                    {trades.length > 0 && (
                        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
                            <h2 className="text-xl font-semibold mb-4">Price Targets</h2>
                            {cryptos.map(crypto => {
                                const cryptoTrades = trades.filter(trade => trade.crypto === crypto);
                                if (cryptoTrades.length === 0) return null;
                                const breakevenPrice = calculateBreakevenPrice(crypto);
                                const liquidationPrice = calculateLiquidationPrice(crypto);
                                const currentPrice = livePrices[crypto];
                                const currentProfitData = calculateCurrentProfit(crypto);
                                const cryptoTargets = priceTargets[crypto] || {};
                                return (
                                    <PriceTargetSection
                                        key={crypto}
                                        crypto={crypto}
                                        breakevenPrice={breakevenPrice}
                                        liquidationPrice={liquidationPrice}
                                        currentPrice={currentPrice}
                                        currentProfitData={currentProfitData}
                                        lastPriceUpdate={lastPriceUpdate}
                                        priceTargets={cryptoTargets}
                                        addPriceTarget={(targetPrice) => addPriceTarget(crypto, targetPrice)}
                                        removePriceTarget={(targetId) => removePriceTarget(crypto, targetId)}
                                        calculateProfit={(targetPrice) => calculateProfit(crypto, targetPrice)}
                                        formatUSD={formatUSD}
                                        formatCurrencyInput={formatCurrencyInput}
                                        parseCurrencyInput={parseCurrencyInput}
                                    />
                                );
                            })}
                        </div>
                    )}
                </div>
            );
        }

        function AddTradeForm({ addTrade, formatCurrencyInput, parseCurrencyInput }) {
            const [crypto, setCrypto] = useState('BTC');
            const [direction, setDirection] = useState('long');
            const [entryPrice, setEntryPrice] = useState('');
            const [positionSize, setPositionSize] = useState('');
            const [leverage, setLeverage] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                const ep = parseCurrencyInput ? parseCurrencyInput(entryPrice) : parseFloat(entryPrice.replace(/,/g, ''));
                const ps = parseFloat(positionSize);
                const lev = parseFloat(leverage);
                if (isNaN(ep) || isNaN(ps) || isNaN(lev) || lev <= 0 || ep <= 0) {
                    alert('Please enter valid numbers for entry price, position size, and leverage (all must be greater than 0).');
                    return;
                }
                addTrade({ crypto, direction, entryPrice: ep, positionSize: ps, leverage: lev });
                setEntryPrice('');
                setPositionSize('');
                setLeverage('');
            };

            return (
                <div>
                    <h3 className="text-lg font-semibold mb-4">Add New Trade</h3>
                    <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label htmlFor="add-crypto" className="block mb-1">Cryptocurrency</label>
                            <select
                                id="add-crypto"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={crypto}
                                onChange={(e) => setCrypto(e.target.value)}
                            >
                                <option value="BTC">BTC</option>
                                <option value="ETH">ETH</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="add-direction" className="block mb-1">Direction</label>
                            <select
                                id="add-direction"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={direction}
                                onChange={(e) => setDirection(e.target.value)}
                            >
                                <option value="long">Long</option>
                                <option value="short">Short</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="add-entry-price" className="block mb-1">Average Entry Price (USD)</label>
                            <input
                                id="add-entry-price"
                                type="text"
                                placeholder="0.00"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={entryPrice}
                                onChange={(e) => setEntryPrice(formatCurrencyInput ? formatCurrencyInput(e.target.value) : e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="add-position-size" className="block mb-1">Position Size (Crypto Units)</label>
                            <input
                                id="add-position-size"
                                type="number"
                                step="0.0001"
                                min="0"
                                placeholder="Position size"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={positionSize}
                                onChange={(e) => setPositionSize(e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="add-leverage" className="block mb-1">Leverage</label>
                            <input
                                id="add-leverage"
                                type="number"
                                step="0.1"
                                min="1"
                                placeholder="Leverage"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={leverage}
                                onChange={(e) => setLeverage(e.target.value)}
                            />
                        </div>
                        <div className="md:col-span-2">
                            <button
                                type="submit"
                                className="w-full md:w-auto mt-2 bg-green-500 text-white p-2 rounded hover:bg-green-600 transition"
                            >
                                Add Trade
                            </button>
                        </div>
                    </form>
                </div>
            );
        }

        function EditTradeForm({ trade, updateTrade, onCancel, formatCurrencyInput, parseCurrencyInput }) {
            const [crypto, setCrypto] = useState(trade.crypto);
            const [direction, setDirection] = useState(trade.direction);
            const [entryPrice, setEntryPrice] = useState(formatCurrencyInput ? formatCurrencyInput(trade.entryPrice.toString()) : trade.entryPrice.toString());
            const [positionSize, setPositionSize] = useState(trade.positionSize.toString());
            const [leverage, setLeverage] = useState(trade.leverage.toString());

            const handleSubmit = (e) => {
                e.preventDefault();
                const ep = parseCurrencyInput ? parseCurrencyInput(entryPrice) : parseFloat(entryPrice.replace(/,/g, ''));
                const ps = parseFloat(positionSize);
                const lev = parseFloat(leverage);
                if (isNaN(ep) || isNaN(ps) || isNaN(lev) || lev <= 0 || ep <= 0) {
                    alert('Please enter valid numbers for entry price, position size, and leverage (all must be greater than 0).');
                    return;
                }
                updateTrade({ crypto, direction, entryPrice: ep, positionSize: ps, leverage: lev });
            };

            return (
                <div>
                    <h3 className="text-lg font-semibold mb-4">Edit Trade</h3>
                    <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label htmlFor="edit-crypto" className="block mb-1">Cryptocurrency</label>
                            <select
                                id="edit-crypto"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={crypto}
                                onChange={(e) => setCrypto(e.target.value)}
                            >
                                <option value="BTC">BTC</option>
                                <option value="ETH">ETH</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="edit-direction" className="block mb-1">Direction</label>
                            <select
                                id="edit-direction"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={direction}
                                onChange={(e) => setDirection(e.target.value)}
                            >
                                <option value="long">Long</option>
                                <option value="short">Short</option>
                            </select>
                        </div>
                        <div>
                            <label htmlFor="edit-entry-price" className="block mb-1">Average Entry Price (USD)</label>
                            <input
                                id="edit-entry-price"
                                type="text"
                                placeholder="0.00"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={entryPrice}
                                onChange={(e) => setEntryPrice(formatCurrencyInput ? formatCurrencyInput(e.target.value) : e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="edit-position-size" className="block mb-1">Position Size (Crypto Units)</label>
                            <input
                                id="edit-position-size"
                                type="number"
                                step="0.0001"
                                min="0"
                                placeholder="Position size"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={positionSize}
                                onChange={(e) => setPositionSize(e.target.value)}
                            />
                        </div>
                        <div>
                            <label htmlFor="edit-leverage" className="block mb-1">Leverage</label>
                            <input
                                id="edit-leverage"
                                type="number"
                                step="0.1"
                                min="1"
                                placeholder="Leverage"
                                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                                value={leverage}
                                onChange={(e) => setLeverage(e.target.value)}
                            />
                        </div>
                        <div className="md:col-span-2 space-x-2">
                            <button
                                type="submit"
                                className="mt-2 bg-green-500 text-white p-2 rounded hover:bg-green-600 transition"
                            >
                                Save Changes
                            </button>
                            <button
                                type="button"
                                onClick={onCancel}
                                className="mt-2 bg-gray-500 text-white p-2 rounded hover:bg-gray-600 transition"
                            >
                                Cancel
                            </button>
                        </div>
                    </form>
                </div>
            );
        }

        function PriceTargetSection({ crypto, breakevenPrice, liquidationPrice, currentPrice, currentProfitData, lastPriceUpdate, priceTargets, addPriceTarget, removePriceTarget, calculateProfit, formatUSD, formatCurrencyInput, parseCurrencyInput }) {
            const [targetPrice, setTargetPrice] = useState('');

            const handleCalculate = () => {
                const tp = parseCurrencyInput ? parseCurrencyInput(targetPrice) : parseFloat(targetPrice.replace(/,/g, ''));
                if (isNaN(tp) || tp <= 0) {
                    alert('Please enter a valid target price greater than 0.');
                    return;
                }
                addPriceTarget(tp);
                setTargetPrice(''); // Clear the input after adding
            };

            return (
                <div className="mb-6 p-4 border rounded-lg border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
                    <h3 className="text-lg font-semibold mb-3">{crypto} Price Targets</h3>

                    {/* Current Price, Breakeven and Liquidation Price Display */}
                    <div className="mb-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        {/* Combined Current Price and Profit/Loss */}
                        <div className={`p-3 border rounded ${
                            currentProfitData && currentProfitData.totalProfit >= 0
                                ? 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800'
                                : 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800'
                        }`}>
                            <p className={`text-sm font-medium mb-2 ${
                                currentProfitData && currentProfitData.totalProfit >= 0
                                    ? 'text-green-800 dark:text-green-200'
                                    : 'text-red-800 dark:text-red-200'
                            }`}>
                                <span className="font-semibold">Current Price:</span> {currentPrice ? formatUSD(currentPrice) : 'Loading...'}
                            </p>
                            <p className={`text-sm font-medium ${
                                currentProfitData && currentProfitData.totalProfit >= 0
                                    ? 'text-green-800 dark:text-green-200'
                                    : 'text-red-800 dark:text-red-200'
                            }`}>
                                <span className="font-semibold">
                                    {currentProfitData && currentProfitData.totalProfit >= 0 ? 'Estimated Profit:' : 'Estimated Loss:'}
                                </span> {currentProfitData ? formatUSD(Math.abs(currentProfitData.totalProfit)) : 'Calculating...'}
                            </p>
                            <p className={`text-xs mt-2 ${
                                currentProfitData && currentProfitData.totalProfit >= 0
                                    ? 'text-green-600 dark:text-green-300'
                                    : 'text-red-600 dark:text-red-300'
                            }`}>
                                {lastPriceUpdate ? `Updated: ${lastPriceUpdate.toLocaleTimeString()}` : 'Fetching live price...'}
                            </p>
                        </div>

                        {/* Breakeven Price */}
                        {breakevenPrice !== null ? (
                            <div className="p-3 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded">
                                <p className="text-sm font-medium text-blue-800 dark:text-blue-200">
                                    <span className="font-semibold">Breakeven Price:</span> {formatUSD(breakevenPrice)}
                                </p>
                                <p className="text-xs text-blue-600 dark:text-blue-300 mt-1">
                                    Price where all {crypto} positions break even
                                </p>
                            </div>
                        ) : (
                            <div className="p-3 bg-gray-100 dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded">
                                <p className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                    <span className="font-semibold">Breakeven Price:</span> N/A
                                </p>
                                <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                    Positions are perfectly hedged
                                </p>
                            </div>
                        )}

                        {/* Liquidation Price */}
                        {liquidationPrice !== null ? (
                            <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded">
                                <p className="text-sm font-medium text-red-800 dark:text-red-200">
                                    <span className="font-semibold">Liquidation Price:</span> {formatUSD(liquidationPrice)}
                                </p>
                                <p className="text-xs text-red-600 dark:text-red-300 mt-1">
                                    Price where entire {crypto} position gets liquidated
                                </p>
                            </div>
                        ) : (
                            <div className="p-3 bg-gray-100 dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded">
                                <p className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                    <span className="font-semibold">Liquidation Price:</span> N/A
                                </p>
                                <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                    Positions are perfectly hedged
                                </p>
                            </div>
                        )}
                    </div>

                    <div className="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-2 mb-3">
                        <input
                            type="text"
                            placeholder="0.00"
                            className="flex-grow p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
                            value={targetPrice}
                            onChange={(e) => setTargetPrice(formatCurrencyInput ? formatCurrencyInput(e.target.value) : e.target.value)}
                        />
                        <button
                            onClick={handleCalculate}
                            className="bg-green-500 text-white p-2 rounded hover:bg-green-600 transition"
                        >
                            Add Target
                        </button>
                    </div>

                    {/* Display all price targets */}
                    {Object.keys(priceTargets).length > 0 && (
                        <div className="space-y-3">
                            {Object.values(priceTargets).map((target) => (
                                <div key={target.id} className="relative p-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded">
                                    {/* Close button */}
                                    <button
                                        onClick={() => removePriceTarget(target.id)}
                                        className="absolute top-2 right-2 w-6 h-6 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 transition flex items-center justify-center text-lg font-normal"
                                        title="Remove target"
                                    >
                                        ×
                                    </button>

                                    <p className="font-semibold mb-2 pr-8">Profits at {formatUSD(target.targetPrice)}:</p>
                                    <div className="space-y-1 text-sm">
                                        {target.profitData.profits.map((item, index) => (
                                            <p key={index} className="flex justify-between">
                                                <span>
                                                    {item.direction.charAt(0).toUpperCase() + item.direction.slice(1)} trade (Entry {formatUSD(item.entryPrice)}):
                                                </span>
                                                <span className={`font-medium ${item.profit >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                                                    {formatUSD(item.profit)}
                                                </span>
                                            </p>
                                        ))}
                                    </div>
                                    <div className="mt-3 pt-2 border-t border-gray-200 dark:border-gray-600">
                                        <p className="flex justify-between font-semibold">
                                            <span>Total Profit for {crypto}:</span>
                                            <span className={`${target.profitData.totalProfit >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                                                {formatUSD(target.profitData.totalProfit)}
                                            </span>
                                        </p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>